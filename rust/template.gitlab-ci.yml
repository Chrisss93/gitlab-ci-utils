# A pipeline template designed for rust projects.  Biased towards the x86_64-unknown-linux-gnu target triple.
#
# In order to mandate audits on project dependencies, include this pipeline and create a job extending
# the .dep-audit job. For this to work, the project's Cargo.toml file must add the entry below:
#
# [package.metadata.vet]
# store = { path = "./.cargo/audits" }
#
# To override the configuration settings for testing, supply-chain checking, etc. provide your own *.toml
# files in the .cargo directory at your project's root. Keep in mind, changing them might require you to
# change parts of the pipeline jobs (ie. if your nextest.toml file is configured to save the junit file to
# some different location).

# This pipeline provides the option to cache certain compiled artifacts of crate dependencies. This should allow
# cargo to avoid re-compiling these dependencies for future builds of this pipeline.  The choice of which dependencies
# to artifact will be project specific.  The relevant jobs provide cargo-timings.html artifacts to help guide this
# decision but some trial and error is required to see which dependencies slow down the build the most and how large
# their compiled artifacts are.  Note: compilation is a complex beast - just because cargo timings shows the crate A
# dependency takes 15 seconds compile doesn't mean the build will speed up by a commensurate amount if you choose to 
# cache crate A.

# TODO
# * Complete the benchmark job (target the load_testing report artifact)
# * Cargo may force recompilation due to docker mounted volumes having filesystems with differen mtime precision
#   It depends on how gitlab project files in containers during jobs. Will need to test.

include:
  - project: chrisss93/ci
    file: docker.gitlab-ci.yml

variables:
  RUST_VERSION: 1.75.0
  JOB_IMAGE: registry.gitlab.com/chrisss93/ci/rust:$RUST_VERSION-test # rust:$RUST_VERSION-slim
  CARGO_HOME: $CI_PROJECT_DIR/cargo_home
  CARGO_BUILD_JOBS: 4
  CARGO_INCREMENTAL: 0
  CARGO_PROFILE_DEV_DEBUG: false
  TEST_CACHE_CRATES: '' # Space separated. Use [crate]@[version-number] if you depend on multiple versions of a crate
  RELEASE_CACHE_CRATES: ''

default:
  image: $JOB_IMAGE
  cache:
    - &cargo-registry-cache
      key: $CI_PROJECT_PATH-cargo-registry
      unprotect: true
      paths:
        - $CARGO_HOME/registry/cache

stages:
  - check
  - test
  - build
  - deploy

setup:
  stage: .pre
  image: registry.gitlab.com/gitlab-ci-utils/curl-jq:1.1.0
  script:
    - >-
      git clone --depth 1 --single-branch --branch fix
      https://gitlab-ci-token:$CI_JOB_TOKEN@$CI_SERVER_HOST/chrisss93/ci.git
      /tmp/ci
    - cp -nr /tmp/ci/rust/.cargo /tmp/ci/rust/save-crates.sh .
  artifacts:
    paths:
      - .cargo/
      - save-crates.sh
    expire_in: 1 hour
  cache: [] # or null?

clippy:
  stage: check
  variables:
    CLIPPY_ARGS: --all-targets --all-features --locked --no-deps
    CARGO_BUILD_TARGET: x86_64-unknown-linux-gnu
    CODE_CLIMATE: |-
      [.[].message | select(.code != null) | . as $$msg | .spans[] | {
      "location": {"path": .file_name , "lines": {"begin": .line_start, "end": .line_end}},
      "description": $$msg.message,
      "fingerprint": ($$msg.code.code + .file_name + (.line_start | tostring)) | @base64,
      "check_name": $$msg.code.code,
      "severity": (
      if [$$msg.level] | contains(["help", "info"]) then "minor"
      elif $$msg.level == "warning" then "major"
      elif $$msg.level == "error" then "critical"
      else "blocker"  end),
      "categories": [
      "Bug Risk", "Clarity", "Compatibility", "Complexity", "Duplication",
      "Performance", "Security", "Style"],
      "type": "issue"
      }]
  script:
    - which cargo-clippy || rustup component add clippy
    - &install-jq >-
      which jq || (
      wget https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64 -O $CI_PROJECT_DIR/jq &&
      chmod +x $CI_PROJECT_DIR/jq && ln -s $CI_PROJECT_DIR/jq /usr/local/bin/jq
      )
    - '[ -d "target/crate-release-cache" ] && (mkdir -p target && mv target/crate-release-cache/* target)'
    - cargo clippy $CLIPPY_ARGS --release --message-format json | jq -s "$CODE_CLIMATE" > clippy.json
    - >-
      if [ -s clippy.json ] && jq -e 'length > 0' clippy.json;
      then cargo clippy $CLIPPY_ARGS --release --color always && exit 222;
      fi
  artifacts:
    when: always
    reports:
      codequality: clippy.json
  allow_failure:
    exit_codes:
      - 222
  cache: 
    - *cargo-registry-cache
    - key: $CI_PROJECT_PATH-release-cache-compile:linux-gnu
      paths:
        - $CI_PROJECT_DIR/target/crate-release-cache
      policy: pull


rustfmt:
  stage: check
  image: rustlang/rust:nightly-alpine3.17
  variables:
    CODE_CLIMATE: |-
      [.[] | (.name | sub($$cwd; "")) as $$name | .mismatches[] | {
      "location": {"path": $$name, "lines": {"begin": .original_begin_line, "end": .original_end_line}},
      "description": ("Expected: " + .expected),
      "fingerprint": (.expected + $$name + (.original_begin_line | tostring)) | @base64,
      "type": "issue", "categories": ["Style"], "severity": "info", "check_name": "rustfmt"
      }]
  script:
    - *install-jq
    - cargo +nightly version || rustup toolchain install nightly
    - >-
      cargo +nightly fmt --all --message-format json -- --config-path .cargo |
      jq --arg cwd "$PWD"/ "$CODE_CLIMATE" > rustfmt.json
    - |-
      if [ -s rustfmt.json ] && jq -e 'length > 0' rustfmt.json
      then cargo +nightly fmt --all --check -- --config-path .cargo --color always || exit 222
      fi
  artifacts:
    when: always
    reports:
      codequality: rustfmt.json
  allow_failure:
    exit_codes: [222]
  cache: []

# The two dependency-* jobs below expose their outputs as both code-quality and dependency-scanning reports
# because dependency-scanning is not available in gitlab's Free tier. If the feature is moved or one has the
# Ultimate Gitlab tier, remove the code-quality report and the 3rd + 4th script steps to avoid redundant signals
# In a larger organization, the cargo-deny and cargo-vet configuration files would not be allowed within a project's
# repo but instead be imported and overwritten from an organization's dedicated centralized security repo so that
# application developers cannot circumvent potential dependency vulnerabilities by unilaterally creating exceptions.

cargo-deny:
  stage: check
  variables:
    CODE_CLIMATE: |-
      .[] | select(.type == "diagnostic" and (.fields.code | contains("license-not-encountered") | not)) | .fields |
      (.message + ": " + (.labels | map(.span + " -> " + .message) | join(".  "))) as $$desc |
      {
      "description": $$desc | sub("\n"; " vs. "),
      "fingerprint": $$desc | @base64,
      "severity": (if .severity == "error" then "critical" else "major" end),
      "check_name": "cargo-deny: \(.code)",
      "type": "issue", "categories": ["Security"],
      "location": {"path": "Cargo.lock", "lines": {}},
      "crateId": .graphs[0].Krate | "name = \(.name | tojson)\nversion = \(.version | tojson)"
      }
    # https://gitlab.com/gitlab-org/security-products/security-report-schemas/-/blob/v15.0.6/dist/dependency-scanning-report-format.json
    SCANNER: >-
      {"id": "cargo-deny", "name": "cargo-deny", "version": "0.13.9", "vendor": {"name": "EmbarkStudios"},
      "url": "https://github.com/EmbarkStudios/cargo-deny"}
    DEP_SCAN: |-
      map(select(.type == "diagnostic" and (.fields.code | contains("license-not-encountered") | not)) | .fields) |
      {
        "version": "15.0.6",
        "vulnerabilities": map(.graphs[0].Krate as $$crate | {
          "id": (.message + $$crate.name + $$crate.version) | @base64,
          "name": .message,
          "description": (.labels | map(.span + " -> " + .message) | join("\n")),
          "severity": (if .severity == "error" then "High" else "Medium"),
          "identifiers": [{
            "type": "licenses/bans/advisories/sources",
            "name": "cargo-deny \($$crate.name) - \($$crate.version)",
            "value": ($$crate.name + " - " + $$crate.version)
          }],
          "location": {
            "file": "Cargo.lock",
            "dependency": {"version": $$crate.version, "package": {"name": $$crate.name}}
          }
        }),
        "dependency_files": [{"path": "Cargo.lock", "package_manager": "cargo", "dependencies": $$deps}],
        "scan": {
          "type": "dependency_scanning",
          "status": "success",
          "start_time": "$CI_JOB_STARTED_AT", "end_time": now | strftime("%Y-%m-%dT%H:%M:%S"),
          "analyzer": $SCANNER, "scanner": $SCANNER
        }
      }
  before_script:
    - *install-jq
    - &binstall >-
      which cargo-binstall || (
      target=$(rustc -vV | grep -oP '(?<=host: ).*') &&
      wget https://github.com/cargo-bins/cargo-binstall/releases/download/v1.4.6/cargo-binstall-$target.tgz -O - |
      tar -xzvf - -C /usr/local/bin
      )
    - which cargo-deny || cargo binstall -y cargo-deny@0.14.3
  script:
    - cargo deny --all-features --locked --format json check --exclude-dev 2> deny.json || true
    - |-
      jq -sc "$CODE_CLIMATE" deny.json | while read -r item; do
      crate=$(printf '%s' "$item" | jq -r '.crateId')

      # Look up the line-number in Cargo.lock for the offending dependency reported by cargo-deny
      line=$(awk -F '\n' -v crate="$crate" '$0 ~ crate{print n+2} {n=n+NF-1}' RS='[[package]]' Cargo.lock)
      
      # Patch deny.json to add the line-number to the code-climate json schema.
      printf '%s' "$item" | jq --argjson line "$line" \
      '.location.lines += {"begin": $line, "end": ($line + 1)} | del(.crateId)' >> patched.json
      done
    - jq -s '.' patched.json > deny-codeclimate.json
    # - >-
    #   cargo metadata --format-version 1 |
    #   jq '.packages | map({"version": .version, "package": {"name": .name}})' > meta.json
    # - jq -s --argjson deps "$(<meta.json)" $DEP_SCAN deny.json > deny-depscan.json
    - |-
      if [ -s deny-codeclimate.json ] && jq -e 'length > 0' deny-codeclimate.json
      then cargo deny --all-features --locked --color always check --exclude-dev --show-stats || exit 222
      fi
  after_script:
    - rm -f deny.json patched.json meta.json
  artifacts:
    when: always
    reports:
      codequality: deny-codeclimate.json
      # dependency_scanning: deny-depscan.json
  allow_failure:
    exit_codes: [222]
  cache: &cargo-bin-cache
    key: $CI_PROJECT_PATH-cargo-binstall
    paths:
      - $CARGO_HOME/bin


cargo-vet:
  stage: check
  variables:
    CODE_CLIMATE: |-
      .suggest.suggestions[]? | 
      {
      "description": ("Dependency: \(.name) version: \(.suggested_diff.to) has not been audited. " +
      "\(.suggested_diff.diffstat.files_changes) file changes, " +
      "\(.suggested_diff.diffstat.insertions) insertions and " +
      "\(.suggested_diff.diffstat.deletions) deletions have occured since its last audit in " +
      "version: \(.suggested_diff.from)."),
      "fingerprint": (.name + .suggested_diff.to) | @base64,
      "check_name": "cargo-vet suggested audit criteria: \(.suggested_criteria)",
      "type": "issue", "categories": ["Security"], "severity": "info",
      "location": {"path": "Cargo.lock", "lines": {}},
      "crateId": "name = \(.name | tojson)\nversion = \(.suggested_diff.to | tojson)"
      }
    SCANNER: >-
      {"id": "cargo-vet", "name": "cargo-vet", "version": "0.6.1", "vendor": {"name": "Mozilla"},
      "url": "https://github.com/mozilla/cargo-vet"}
    # https://gitlab.com/gitlab-org/security-products/security-report-schemas/-/blob/v15.0.6/dist/dependency-scanning-report-format.json
    DEP_SCAN: |-
      .suggest.suggestions |
      {
        "version": "15.0.6",
        "vulnerabilities": map({
          "id": "\(.suggested_criteria)\(.name)\(.suggested_diff.to)" | @base64,
          "name": "Missing audit criteria: \(.suggested_criteria)",
          "solution": "Audit \(.name) (\(.suggested_diff.to)) for the criteria: \(.suggested_criteria)",
          "description": (
            "Dependency: \(.name) version: \(.suggested_diff.to) has not been audited. " +
            "\(.suggested_diff.diffstat.files_changes) file changes, \(.suggested_diff.diffstat.insertions) " +
            "insertions and \(.suggested_diff.diffstat.deletions) deletions since its last audit in version: " +
            .suggested_diff.from),
          "severity": "Low",
          "identifiers": [{
            "type": "audits",
            "name": "cargo-vet \(.name) - \(.suggested_diff.to)",
            "value": (.name + " - " + .suggested_diff.to)
          }],
          "location": {
            "file": "Cargo.lock",
            "dependency": {"version": .suggested_diff.to, "package": {"name": .name}}}
        }),
        "dependency_files": [{"path": "Cargo.lock", "package_manager": "cargo", "dependencies": $$deps}],
        "scan": {
          "type": "dependency_scanning",
          "status": "success",
          "start_time": "$CI_JOB_STARTED_AT", "end_time": now | strftime("%Y-%m-%dT%H:%M:%S"),
          "analyzer": $SCANNER, "scanner": $SCANNER
        }
      }
  script:
    - *install-jq
    - *binstall
    - which cargo-vet || cargo binstall -y cargo-vet@0.9.1
    - cargo vet --output-format json --output-file vet.json || true
    - jq -e 'has("errors")' && cargo vet
    - |-
      jq -c "$CODE_CLIMATE" vet.json | while read -r item; do
      crate=$(printf '%s' "$item" | jq -r '.crateId')

      # Look up the line-number in Cargo.lock for the offending dependency reported by cargo-vet
      line=$(awk -F '\n' -v crate="$crate" '$0 ~ crate{print n+2} {n=n+NF-1}' RS='[[package]]' Cargo.lock)
      
      # Patch vet.json to add the line-number to the code-climate json schema.
      printf '%s' "$item" | jq --argjson line "${line:-0}" \
      '.location.lines += {"begin": $line, "end": ($line + 1)} | del(.crateId)' >> patched.json
      done
    - jq -s '.' patched.json > vet-codeclimate.json
    # - >-
    #   cargo metadata --format-version 1 |
    #   jq '.packages | map({"version": .version, "package": {"name": .name}})' > meta.json
    # - jq --argjson deps "$(<meta.json)" $DEP_SCAN vet.json > vet-depscan.json
    - |-
      if [ -s vet-codeclimate.json ] && jq -e 'length > 0' vet-codeclimate.json
      then cargo vet; exit 222
      fi
  after_script:
    - rm -f vet.json patched.json meta.json
  artifacts:
    when: always
    reports:
      codequality: vet-codeclimate.json
      # dependency_scanning: vet-depscan.json
  allow_failure:
    exit_codes:
      - 222
  cache: *cargo-bin-cache


test-compile:
  stage: test
  variables:
    CRATES: $TEST_CACHE_CRATES
  script:
    - *install-jq
    - which cargo-nextest || cargo binstall -y cargo-nextest@0.9.70
    # Load specific pre-compiled dependencies from a gitlab cache
    - '[ -d "target/crate-test-cache" ] && (mkdir -p target && mv target/crate-test-cache/* target)'
    # Compile instrumented test binaries
    - export RUSTFLAGS='-C instrument-coverage --cfg=coverage --cfg=trybuild_no_target'
    - export LLVM_PROFILE_FILE=target/debug/%p-%m.profraw
    - >-
      cargo nextest list --message-format json --config-file .cargo/nextest.toml --locked --verbose --all-features
      --timings > tests.json
    - mv target/cargo-timings/cargo-timing.html target/cargo-timings/test-compile.html
    # Save specific pre-compiled dependencies to a gitlab cache
    - cargo test --no-run --message-format json-render-diagnostics > diagnostics.json
    - ./save-crates.sh -j diagnostics.json target/crate-test-cache $CRATES
    # Prepare minimal nextest-archive
    - mkdir -p target/nextest/debug
    - >-
      jq '.["rust-binaries"] = (
        .["rust-suites"] | to_entries | [
        .[] | select(.value.testcases | length > 0) |
        .value["binary-path"] |= "target/llvm-cov-target/target/nextest/debug/" + split("/")[-1]
        ] | from_entries
      ) |
      .["rust-build-meta"]["non-test-binaries"] = {} |
      del(.["rust-suites"])' tests.json > target/nextest/binaries-metadata.json
    - cargo metadata --no-deps --locked --format-version 1 > target/nextest/cargo-metadata.json
    - >-
      jq -r '.["rust-suites"] | .[] | select(.testcases | length > 0) | .["binary-path"]' tests.json |
      xargs -I {} mv {} target/nextest/debug
    - tar -acvf nextest.tar.zst target/nextest
  artifacts:
    expose_as: test-executables
    paths:
      - target/cargo-timings/test-compile.html
      - nextest.tar.zst
    expire_in: 1 hour
  needs:
    - setup
  cache:
    - *cargo-registry-cache
    - &crate-test-cache
      key: $CI_PROJECT_PATH-test-cache
      paths:
        - $CI_PROJECT_DIR/target/crate-test-cache


unit-tests:
  stage: test
  script:
    - which cargo-nextest || cargo binstall -y cargo-nextest@0.9.70
    - which cargo-llvm-cov || cargo binstall -y cargo-llvm-cov@0.6.9
    - cargo llvm-cov nextest --config-file .cargo/nextest.toml --archive-file nextest.tar.zst --no-report -- $TEST_ARGS
    - ln -s target/nextest/debug target/llvm-cov-target/debug
    - cargo llvm-cov report
    - mkdir target/prof
    - mv target/llvm-cov-target/*.profdata target/prof/$CI_JOB_NAME.profraw
  artifacts:
    reports:
      junit: target/nextest/default/junit.xml
    expose_as: profile-data
    paths:
      - target/prof/$CI_JOB_NAME.profraw
    expire_in: 1 day
  needs:
    - setup
    - test-compile


expensive-tests:
  extends: unit-tests
  variables:
    TEST_ARGS: --ignored
  rules:
    - if: $CI_COMMIT_TAG || $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_MERGE_REQUEST_ID
      when: manual


coverage:
  stage: test
  script:
    - *install-jq
    - which cargo-llvm-cov || cargo binstall -y cargo-llvm-cov@0.6.9
    - mv target/prof target/llvm-cov-target
    - tar -axvf nextest.tar.zst --strip-components 2 -C target/llvm-cov-target target/nextest/debug
    - cargo llvm-cov --ignore-filename-regex '/?main.rs' report --cobertura --output-path target/llvm-cov-report.xml
    - cargo llvm-cov --ignore-filename-regex '/?main.rs' report --html --output-dir target/llvm-cov-target
    - cargo llvm-cov --ignore-filename-regex '/?main.rs' report
    - >-
      cargo llvm-cov --ignore-filename-regex '/?main.rs' report --json |
      jq -r '(.data | map(.totals.regions.covered) | add) / (.data | map(.totals.regions.count) | add) |
      "Region coverage: \(. * 10000 | round | . / 100)%"'
  coverage: '/^Region coverage: (\d+\.\d+%)$/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: target/llvm-cov-report.xml
    expose_as: report
    paths:
      - target/llvm-cov-target/html/
  needs:
    - test-compile
    - unit-tests
    - job: expensive-tests
      optional: true


compile:linux-gnu:
  stage: build
  variables:
    CARGO_BUILD_TARGET: x86_64-unknown-linux-gnu
    CRATES: $RELEASE_CACHE_CRATES
  script:
    - *install-jq
    - >-
      cargo metadata --format-version 1 --no-deps |
      jq -e '.packages[].targets[] | select(.kind | contains(["bin"]))' ||
      (echo "No binaries to build" && exit 0)
    # Load specific pre-compiled dependencies from a gitlab cache
    - '[ -d "target/crate-release-cache" ] && (mkdir -p target && mv target/crate-release-cache/* target)'
    - cargo build --release --locked --timings --message-format json-render-diagnostics > diagnostics.json
    - mv target/cargo-timings/cargo-timing.html target/cargo-timings/$CARGO_BUILD_TARGET.html
    # Save specific pre-compiled dependencies to a gitlab cache
    - ./save-crates.sh -j diagnostics.json -t $CARGO_BUILD_TARGET target/crate-release-cache $CRATES
    - mkdir -p binaries
    - >-
      cargo metadata --format-version 1 --no-deps |
      jq -r ".packages[].targets[] | select(.kind | contains([\"bin\"])) |
        \"target/$CARGO_BUILD_TARGET/release/\" + .name" |
      tar czvf binaries/$CARGO_BUILD_TARGET.tar.gz -T -
  after_script:
    # Upload binary to package registry if the pipeline was triggered by a git tag
    - '[ -z "$CI_COMMIT_TAG" ] && exit 0'
    - url=$CI_API_V4_URL/projects/$CI_PROJECT_ID/packages/generic/binary/${CI_COMMIT_TAG#v}/$(ls binaries)
    - 'wget "$url" -S -O - --header "JOB-TOKEN: $CI_JOB_TOKEN" --method PUT --body-file binaries/*'
    # Prepare release asset
    - mkdir -p assets
    - |-
      cat <<EOF > assets/$CARGO_BUILD_TARGET.json
        {
          "name": "Binary ($CARGO_BUILD_TARGET)",
          "url": "$url",
          "direct_asset_path": "$(ls binaries/*)"
        }
      EOF
  artifacts:
    paths:
      - binaries/$CARGO_BUILD_TARGET.*
      - assets/$CARGO_BUILD_TARGET.json
      - target/cargo-timings/$CARGO_BUILD_TARGET.html
    expire_in: 1 week
  cache:
    - *cargo-registry-cache
    - &crate-release-cache
      key: $CI_PROJECT_PATH-release-cache-$CI_JOB_NAME
      paths:
        - $CI_PROJECT_DIR/target/crate-release-cache
  dependencies:
    - setup

# It would be cleaner and more succinct to declare all these compile (binary release build) jobs in a single
# parallel matrix job.  However we would run into an arbitrary character limitation on job names.
# Once the following issues are resolved, we can unite this into a single job:
# https://gitlab.com/groups/gitlab-org/-/epics/11791

.compile:linux-musl:
  extends: compile:linux-gnu
  image: registry.gitlab.com/chrisss93/ci/rust/alt-target:$RUST_VERSION
  variables:
    CARGO_BUILD_TARGET: x86_64-unknown-linux-musl
    RUSTFLAGS: -C link-arg=-fuse-ld=mold -C target-feature=-crt-static


.compile:windows:
  extends: .compile:linux-musl
  variables:
    CARGO_BUILD_TARGET: x86_64-pc-windows-gnu
    RUSTFLAGS: -C linker=x86_64-w64-mingw32-gcc -C ar=/usr/x86_64-w64-mingw32/bin/ar
  script:
    - !reference [compile:linux-gnu, script]
    - rm binaries/$CARGO_BUILD_TARGET.tar.gz
    - >-
      cargo metadata --format-version 1 --no-deps |
      jq -r ".packages[].targets[] | select(.kind | contains([\"bin\"])) |
        \"target/$CARGO _BUILD_TARGET/release/\" + .name" |
      zip binaries/$CARGO_BUILD_TARGET.zip -@


# Maybe write this around criterion/iai? (or else rust nightly may be required...)
# --all-targets might accidentally call the unit-tests, need to check.
.benchmark:
  stage: build
  rules:
    - if: $CI_COMMIT_TAG || $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - when: manual
  variables:
    CRATES: $TEST_CACHE_CRATES
    CARGO_ARGS: --locked --verbose --all-targets --all-features
    # JQ_EXPR: |-
  script:
    - *install-jq
    - >-
      cargo metadata --format-version 1 --no-deps |
      jq -e '.packages[].targets[] | select(.kind | contains(["bench"]))' ||
      (echo "No benchmarks to run" && exit 0)
    - *binstall
    - # Test if using iai-callgrind for benching and if so, binstall the iai-callgrind-runner
      # cargo binstall -y iai-callgrind-runner@0.11.0
    - '[ -d "target/crate-bench-cache" ] && (mkdir -p target && mv target/crate-bench-cache/* target)'
    # Maybe do something about the baselines
    - cargo bench $CARGO_ARGS -- --output-format json | jq -s $JQ_EXPR > benchmarks.json
    # Save specific pre-compiled dependencies to a gitlab cache
    - cargo bench $CARGO_ARGS --no-run --message-format json-render-diagnostics > diagnostics.json
    - ./save-crates.sh -j diagnostics.json target/crate-bench-cache $CRATES
  artifacts:
    reports:
      # load_performance: benchmarks.json # deprecated in 17.0
      # metrics: benchmarks.json # Waiting for delta feature
    expire_in: 2 weeks
  dependencies:
    - setup
  cache:
    - *cargo-registry-cache
    - key: $CI_PROJECT_PATH-benchmark-cache
      paths:
        - $CI_PROJECT_DIR/target/crate-bench-cache


.clear-cache:
  stage: .post
  image: alpine:3.18
  rules:
    - when: manual
  allow_failure: true
  script:
    - mkdir -p target/crate-test-cache target/crate-release-cache
  parallel:
    matrix:
      - JOB_CACHE_NAME: [compile:linux-gnu, compile:linux-musl, compile:windows]
  cache:
    - <<: *crate-test-cache
      policy: push
    - <<: *crate-release-cache
      key: $CI_PROJECT_PATH-release-cache-$JOB_CACHE_NAME
      policy: push
  dependencies: []


pages:
  stage: .post
  rules:
    - if: $CI_COMMIT_TAG
  variables:
    ASSETS: |-
      [
        {
          "name": "Documentation",
          "link_type": "runbook",
          "url": "$CI_API_V4_URL/projects/$CI_PROJECT_ID/jobs/$CI_JOB_ID/artifacts/docs.tar.gz"
        },
        {
          "name": "Test coverage report",
          "url": "$CI_API_V4_URL/projects/$CI_PROJECT_ID/jobs/$CI_JOB_ID/artifacts/coverage.tar.gz"
        },
        {
          "name": "Build time report",
          "url": "$CI_API_V4_URL/projects/$CI_PROJECT_ID/jobs/$CI_JOB_ID/artifacts/public/build-time.html"
        },
        {
          "name": "Third party licenses",
          "url": "$CI_API_V4_URL/projects/$CI_PROJECT_ID/jobs/$CI_JOB_ID/artifacts/public/licences.html"
        }
      ]
  before_script:
    - *install-jq
    - *binstall
    - which cargo-about || cargo binstall -y cargo-about@0.6.1
    # - which mdbook || cargo binstall -y mdbook@0.4.35
    # - which tree || apt-get update && apt-get-install -y --no-install-recommends tree
  script:
    - 'echo "Creating gitlab release: ${CI_COMMIT_TAG#v}"'
    - mkdir -p public
    - cargo doc --no-deps --document-private-items --all-features && tar czf docs.tar.gz target/doc
    - cargo about generate -o public/licenses.html -c .cargo/about/about.toml .cargo/about/about.hbs
    # -  mdbook build -d public/book dev/book && tar czf book.tar.gz public/book
    - tar czf coverage.tar.gz target/llvm-cov/html
    - >-
      jq -s --argjson assets "$ASSETS" '
      {
        "tag_name": "$CI_COMMIT_TAG",
        "description": "Triggered by git tag: $CI_COMMIT_TAG - $CI_COMMIT_TAG_MESSAGE",
        "assets": {"links": (. + $assets)}
      }' assets/*.json > release.json
    - >-
      wget -S -O - $CI_API_V4_URL/projects/$CI_PROJECT_ID/releases
      --header "JOB-TOKEN: $CI_JOB_TOKEN"
      --header 'Content-Type: application/json'
      --method POST --body-file release.json
    - echo "Setting up Pages"
    - mv target/doc public/docs
    - mv target/cargo-timings public/build-times
    - mv target/llvm-cov-target/html public/test-coverage
    - 'cp public/build-times/$(rustc -vV | grep -oP "(?<=host: ).*").html public/build-time.html'
    - >-
      sed "
      s|__STUB_NAME__|$CI_PROJECT_NAME|g;
      s|__STUB_VERSION__|${CI_COMMIT_TAG#v}|g;
      s|__STUB_PIPELINE_ID__|$CI_PIPELINE_ID|g;
      s|__STUB_SOURCE_URL__|$CI_PROJECT_URL|g;
      s|__STUB_RELEASE_URL__|$CI_PROJECT_URL/-/releases/${CI_COMMIT_TAG#v}|g;
      s|__STUB_PIPELINE_URL__|$CI_PIPELINE_URL|g;
      s|__STUB_DOC_URL__|docs|g;
      s|__STUB_LICENSE_URL__|licenses.html|g;
      s|__STUB_COVERAGE_URL__|test-coverage/index.html|g;
      s|__STUB__TIMING__URL__|build-time.html|e;"
      .cargo/index.html > public/index.html
  artifacts:
    paths:
      - public
      - '{docs,coverage,book}.tar.gz'
  cache: *cargo-bin-cache
